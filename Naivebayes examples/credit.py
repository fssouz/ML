# -*- coding: utf-8 -*-
"""credit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tLUMlZVc4A8co7FwbCFhWUhjcNo1Tzbg
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px

base_credit = pd.read_csv('/content/sample_data/credit_data.csv')

base_credit
#cliente, salário, idade, dívida, N pagou(1) ou pagou(0)
#continua icome,age, loan
#dsicreta clienteid, default

base_credit.head()

base_credit.describe()
#quantidade, média, valor máximo

base_credit[base_credit['income'] >= 69995]

np.unique(base_credit['default'], return_counts=True)

sns.countplot(x=base_credit['default'])

#qnt idade
plt.hist(x = base_credit['age']);

#quantidade rendas
plt.hist(x = base_credit['income'])

plt.hist(x = base_credit['loan'])

grafico = px.scatter_matrix(base_credit, dimensions=['age', 'income', 'loan'], color="default")
grafico.show()
#observar valores foras do padrão

#tratamento de valores inconsistentes
base_credit.loc[base_credit['age'] < 0]

base_credit[base_credit['age'] < 0]

#apagar a coluna
base_credit2 = base_credit.drop('age', axis = 1)
base_credit2

#apagar os registro
base_credit3 = base_credit.drop(base_credit[base_credit['age'] <0].index)
base_credit3

#preencher os valores inconsistentes manualmente
#preencher com a média da idade
base_credit3.mean()
base_credit['age'][base_credit['age'] > 0].mean()

base_credit.loc[base_credit['age'] < 0, 'age'] = 40.92
base_credit.loc[base_credit['age'] <0].index

base_credit.head(16)

#procurar valores faltantes
base_credit.isnull()

base_credit.isnull().sum()
#três campos idade sem registro

base_credit.loc[pd.isnull(base_credit['age'])]

base_credit['age'].fillna(base_credit['age'].mean(), inplace = True)

base_credit.loc[pd.isnull(base_credit['age'])]

#base_credit.loc[base_credit['clientid'].isin([29, 31, 32])]
base_credit.loc[(base_credit['clientid'] == 29) | (base_credit['clientid'] == 31) | (base_credit['clientid'] == 32)]

#divisão entre previsores e classe

X_credit = base_credit.iloc[:, 1:4].values

X_credit

Y_credit = base_credit.iloc[:, 4].values

Y_credit

X_credit[:, 0].min(), X_credit[:, 1].min(), X_credit[:, 2].min()
#valores minimo da renda, idade e crédito

X_credit[:, 0].max(), X_credit[:, 1].max(), X_credit[:, 2].max()
#valores máximos da renda, idade e crédito

#deixar as colunas renda, idade, crédito na mesma escala
#evitar que um algoritimo entenda que um atributo é mais importante que o outro
from sklearn.preprocessing import StandardScaler
scaler_credit = StandardScaler()
X_credit = scaler_credit.fit_transform(X_credit)

X_credit[:, 0].max(), X_credit[:, 1].max(), X_credit[:, 2].max()
#valores máximos da renda, idade e crédito

#divisão treino e teste
from sklearn.model_selection import train_test_split
X_credit_treinamento, X_credit_teste, Y_credit_treinamento, Y_credit_teste = train_test_split(X_credit, Y_credit, test_size = 0.25, random_state = 0)

X_credit_treinamento.shape

Y_credit_treinamento.shape

X_credit_teste.shape, Y_credit_teste.shape

import pickle

with open('credit.pkl', mode = 'wb' ) as f:
  pickle.dump([X_credit_treinamento, Y_credit_treinamento, X_credit_teste, Y_credit_teste], f)

#Naive bayes

"""
abordagem probabilísitca(Teorema de bayes)

ex:filtros de spam, mineração de emoçoes, separação de documentos
"""

X_credit_teste.shape, Y_credit_teste.shape

naive_credit_data = GaussianNB()
naive_credit_data.fit(X_credit_treinamento, Y_credit_treinamento)

#treinando com o conjunto de teste
previsoes = naive_credit_data.predict(X_credit_teste)

previsoes

#comprar previsoes vs Y_teste(com as respostas certa)
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

accuracy_score(Y_credit_teste, previsoes)
#dos 500 registros 93,8% acertos

confusion_matrix(Y_credit_teste, previsoes)
#428 acertos class como pagam
#8 clientes que pagam mas que foram classificados como não pagam
#41 não pagam, class como não pagam
#23 que não pagam, class como pagam

from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(naive_credit_data)
cm.fit(X_credit_treinamento, Y_credit_treinamento)
cm.score(X_credit_teste, Y_credit_teste)

print(classification_report(Y_credit_teste, previsoes))